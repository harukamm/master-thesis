\chapter{序論}\label{chap:intro}

関数型言語の初学者が関数型言語を学び始めたとき，
数々の本質的でない問題に陥りやすい．
変数に何らかの値を再代入しようとしてシンタックスエラーを起こしたり，
Int型とFloat型を持つ値を足し合わせようとして型エラーになってしまうことがある．
関数型言語のシンタックスや静的型付けに慣れていない初学者にとって，
テキストエディタは入力の自由度が高すぎるため，
エラーの原因を特定するのはしばしば困難である．

プログラミング初学者がプログラミング学習のために用いるツールの1つにビジュアルプログラミング環境がある\cite{Viscuit,Scratch,Snap}．
ビジュアルプログラミング環境では，テキストではなく，視覚的なオブジェクトを組み合わせることでプログラミングを行う．
例えば，近松らの\cite{HaskellVP}は，
変数や構文をノードで表し，ノードを線で繋いで値の入出力の関係を制御することによって，
Haskellプログラムをグラフとして表現する．

一方で，Googleの提供するBlockly \cite{Blockly}はブラウザにおけるビジュアルプログラミング環境構築のライブラリとして配布されているオープンソースプロジェクトであり，完全にクライアントサイドのみで動く．
ブロックの描画や移動，組み立てなどといったユーザインタフェースに関わる実装はライブラリ側が全て行なっているため，
ブロックに表示する文字や入出力の関係を定義するだけで，カスタマイズされたブロックを持つビジュアルプログラミング環境を作ることができる．
実装言語はJavaScriptであり，ブロックの描画にはSVGやCSSが活用されている．
また，Blocklyの標準のブロックであれば，ユーザが組み立てたブロック群から，JavaScript，Pythonなどといったスクリプト言語に変換することができる．

% グラフ型のビジュアルプログラミング言語との比較．なぜブロック型を採用したか．見た目的に取っつきやすい．Blocklyは開発者向けなので改造しやすい．
% 構文木とブロックが一対一対応であるのが視覚的にわかりやすく，シンタックスエラーが起こり得ない．
% ブロック型は関数型言語の上で重要な入出力の関係を載せるのに向いていない\cite{HaskellVP}が，（なにか主張を書く）
% なぜOCamlなのか
% sytaxになれる
本研究では，既に洗練されたユーザインタフェースが用意されていることや，構文木と一対一対応をしていて，テキストを連想しやすいことから，
BlocklyをベースとしてOCamlビジュアルプログラミング環境を実装し，これをOCaml Blocklyと名付けた．
OCaml Blocklyでは，不正なプログラムを表すブロックを組み立てることをユーザインタフェースによって制限する．
また，各ブロックが持つ型を形や色で表して，視覚的に出力する．%のように
関数型言語の初学者が，OCaml Blocklyの元でOCamlプログラミングを行うことで，以下の利点を得られることを期待している．
\begin{itemize}
  \item OCamlのシンタックスに慣れる．
  \item 自身が組み立てようとするプログラムが不正なものであることに瞬時に気づくことができ，テキストベースよりもストレスが少なく，OCamlプログラミングの本質を優先的に学習できる．
  \item 静的型付けを理解する．%OCamlのセマンティックスになれる
\end{itemize}
%関数型言語初学者がOCamlを学習する際の導入段階に使用し，シームレスにテキストベースによるプログラミングに繋がるようにすることが狙いである．
また，ブロックによるプログラミングによってOCamlの言語仕様に慣れ親しんだのち，シームレスにテキストベースによるプログラミングに繋がるように，本研究ではブロックとOCamlコードの相互変換の実装を行った．

本論文の構成を以下に示す．まず，{\bf 第\ref{sec:blocklyWord}章}でBlockly固有の用語を説明し，
{\bf 第\ref{sec:senko}章}にて関連研究とその問題点について分析し，その問題点を踏まえて本研究が将来的に達成すべき目標と，
本論文で達成するべき目標を示す．
次に，{\bf 第\ref{sec:honkenkyu}章}で本論文が実装した主な機能を紹介し，
その各機能の実装の詳細を{\bf 第\ref{sec:impl}章}にて説明する．
{\bf 第\ref{sec:converter}章}でブロックとOCamlコードとの相互変換を行うためのシステムの構成を述べる．
{\bf 第\ref{sec:seiri}章}で本システムの現状をまとめ，最終的な目標の達成のために実現されるべき課題を整理し，考察する．
最後に，{\bf 第\ref{sec:matome}章}にて本論文をまとめ，今後のさらなる展望について言及する．
