% http://www.slis.tsukuba.ac.jp/~fujisawa.makoto.fu/cgi-bin/wiki/index.php?BibTeX

% https://dl.acm.org/citation.cfm?doid=2702123.2702302
% https://github.com/UCSD-PL/typed-blockly

@misc{Viscuit,
 title = {Viscuit},
 howpublished = {https://www.viscuit.com/}
}

@misc{Scratch,
 title = {Scratch},
 howpublished = {https://scratch.mit.edu/}
}

@misc{Snap,
 title = {Snap!},
 howpublished = {https://snap.berkeley.edu/}
}

@misc{Blockly,
 title = {Blockly},
 howpublished = {https://developers.google.com/blockly/}
}

@misc{CodeWorld,
 title = {CodeWorld},
 howpublished = {https://github.com/google/codeworld}
}

@misc{FunBlocks,
 title = {FunBlocks},
 howpublished = {https://stefanj.me/funblocks/}
}

@misc{BlocklyForHaskell,
 key = {D},
 howpublished = {https://ymir.eng.kagawa-u.ac.jp/~sano/}
}

@article{HaskellVP,
  author = {近松万由子 and 岩崎英哉 and 中野圭介},
  title = {関数型言語の初学者のための Haskell のビジュアルプログラミング環境},
  journal = {第20回プログラミングおよびプログラミング言語ワークショップ},
  year = {2018},
}

@inproceedings{Typed-Blockly,
 author = {Lerner, Sorin and Foster, Stephen R. and Griswold, William G.},
 title = {{Polymorphic Blocks: Formalism-Inspired UI for Structured Connectors}},
 booktitle = {Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems},
 series = {CHI '15},
 year = {2015},
 isbn = {978-1-4503-3145-6},
 location = {Seoul, Republic of Korea},
 pages = {3063--3072},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/2702123.2702302},
 doi = {10.1145/2702123.2702302},
 acmid = {2702302},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {block-based programming environments, games, proofs},
}

@InProceedings{10.1007/978-3-642-41582-1_12,
author="Tsushima, Kanae
and Asai, Kenichi",
editor="Hinze, Ralf",
title="An Embedded Type Debugger",
booktitle="Implementation and Application of Functional Languages",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="190--206",
abstract="This paper presents how to build a type debugger without implementing any dedicated type inferencer. Previous type debuggers required their own type inferencers apart from the compiler's type inferencer. The advantage of our approach is threefold. First, by not implementing a type inferencer, it is guaranteed that the debugger's type inference never disagrees with the compiler's type inference. Secondly, we can avoid the pointless reproduction of a type inferencer that should work precisely as the compiler's type inferencer. Thirdly, our approach is robust to updates of the underlying language. The key observation of our approach is that the interactive type debugging, as proposed by Chitil, does not require a type inference tree but only a tree with a certain simple property. We identify the property and present how to construct a tree that satisfies this property using the compiler's type inferencer. The property guides us how to build a type debugger for various language constructs. In this paper, we describe our idea and first apply it to the simply-typed lambda calculus. After that, we extend it with let-polymorphism and objects to see how our technique scales.",
isbn="978-3-642-41582-1"
}

@inproceedings{Stepper,
  author    = {Youyou Cong and Kenichi Asai},
  title     = {Implementing a stepper using delimited continuations},
  booktitle = {SCSS 2016. 7th International Symposium on  Symbolic Computation in Software Science},
  editor    = {James H. Davenport and Fadoua Ghourabi},
  series    = {EPiC Series in Computing},
  volume    = {39},
  pages     = {42--54},
  year      = {2016},
  publisher = {EasyChair},
  bibsource = {EasyChair, https://easychair.org},
  issn      = {2398-7340},
  url       = {https://easychair.org/publications/paper/7qlb},
  doi       = {10.29007/l2wb}
}

@book{AkaHon,
 author = {五十嵐淳},
 title = {プログラミング言語の基礎概念},
 publisher = {サイエンス社},
 year = {2011},
}

@book{AsaiBook,
 author = {浅井健一},
 title = {プログラミングの基礎},
 publisher = {サイエンス社},
 year = {2007},
}

@inproceedings{Two-level_types,
 author = {Sheard, Tim and Pasalic, Emir},
 title = {Two-level Types and Parameterized Modules},
 booktitle = {JFP 14:5},
 issue_date = {September 2004},
 year = {2004},
 issn = {0956-7968},
 pages = {547--587},
 numpages = {41},
 url = {https://doi.org/10.1017/S095679680300488X},
 doi = {10.1017/S095679680300488X},
 acmid = {1014379},
} 

@Inproceedings{Companion,
  author    = {Magalh\~aes, Jos\'e Pedro and L\"oh, Andres},
  year      = {2012},
  title     = {{A Formal Comparison of Approaches to Datatype-Generic Programming}},
  editor    = {Chapman, James and Levy, Paul Blain},
  series    = {EPTCS},
  volume    = {76},
  pages     = {50-67},
  doi       = {10.4204/EPTCS.76.6},
}

@inproceedings{PolyP,
 author      ="P. Jansson and J. Jeuring",
 title       ="Poly{P} - a polytypic programming language extension",
 booktitle   ="{POPL} '97",
 pages       ="470--482", 
 year        ="1997",
 documentURL ="http://www.cse.chalmers.se/~patrikj/poly/polypPOPL97/"
}

@inproceedings{IndexedFunctor,
 author = {L\"{o}h, Andres and Magalh\~{a}es, Jos{\'e} Pedro},
 title = {{Generic Programming with Indexed Functors}},
 booktitle = {WGP '11},
series = {},
 year = {2011},
 isbn = {978-1-4503-0861-8},
 location = {Tokyo, Japan},
 pages = {1--12},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/2036918.2036920},
 doi = {10.1145/2036918.2036920},
 acmid = {2036920},
 keywords = {agda, datatype-generic programming, dependently-typed programming, indexed functor},
} 
